use ark_bn254::{Fr, G1Affine};
use ark_ec::{AffineRepr, CurveGroup};
use light_poseidon::{Poseidon, PoseidonHasher};

use crate::{AnchoredProof, split_fq_to_fr};

/// Verification context containing public parameters
pub struct VerificationContext {
    pub generator_g: G1Affine,
    pub generator_h: G1Affine,
    pub generator_b: G1Affine,
    pub anchor: G1Affine,
    pub tree_root: [u8; 32],
}

/// Verify the DLEQ proof: proves that log_B(U) = log_C(C')
/// In other words, verifies that U = B*s and C' = C*s for the same s
fn verify_dleq_proof(
    public1: &G1Affine,  // U (anchor)
    public2: &G1Affine,  // C' (modified_commitment)
    generator1: &G1Affine,  // B
    generator2: &G1Affine,  // C (commitment)
    r_commitment_1: &G1Affine,  // R1
    r_commitment_2: &G1Affine,  // R2
    response: &Fr,  // z
) -> bool {
    // Recompute challenge: H(U, C', R1, R2)
    let u_limbs = split_fq_to_fr(&public1.x().unwrap());
    let c_modified_limbs = split_fq_to_fr(&public2.x().unwrap());
    let r1_limbs = split_fq_to_fr(&r_commitment_1.x().unwrap());
    let r2_limbs = split_fq_to_fr(&r_commitment_2.x().unwrap());

    let mut poseidon = Poseidon::<Fr>::new_circom(8).unwrap();
    let challenge = match poseidon.hash(&[
        u_limbs[0], u_limbs[1],
        c_modified_limbs[0], c_modified_limbs[1],
        r1_limbs[0], r1_limbs[1],
        r2_limbs[0], r2_limbs[1],
    ]) {
        Ok(c) => c,
        Err(_) => return false,
    };

    // Verify: R1 = G1*z - U*challenge
    // Which means: G1*z = R1 + U*challenge
    let left1 = (*generator1) * response;
    let right1 = *r_commitment_1 + (*public1) * challenge;
    let check1 = left1.into_affine() == right1.into_affine();

    // Verify: R2 = G2*z - C'*challenge
    // Which means: G2*z = R2 + C'*challenge
    let left2 = (*generator2) * response;
    let right2 = *r_commitment_2 + (*public2) * challenge;
    let check2 = left2.into_affine() == right2.into_affine();

    check1 && check2
}

/// Verify the Schnorr proof: proves knowledge of t such that R_H = H*t
fn verify_schnorr_proof(
    public: &G1Affine,  // R_H
    generator: &G1Affine,  // H
    commitment: &G1Affine,  // r (commitment in proof)
    response: &Fr,  // z
) -> bool {
    // Recompute challenge: H(R_H, r)
    let pk_limbs = split_fq_to_fr(&public.x().unwrap());
    let r_limbs = split_fq_to_fr(&commitment.x().unwrap());

    let mut poseidon = Poseidon::<Fr>::new_circom(4).unwrap();
    let challenge = match poseidon.hash(&[
        pk_limbs[0], pk_limbs[1],
        r_limbs[0], r_limbs[1],
    ]) {
        Ok(c) => c,
        Err(_) => return false,
    };

    // Verify: r = H*z - R_H*challenge
    // Which means: H*z = r + R_H*challenge
    let left = (*generator) * response;
    let right = *commitment + (*public) * challenge;

    left.into_affine() == right.into_affine()
}

/// Verify an anchored merkle proof
/// 
/// This verifies:
/// 1. The merkle proof (that the leaf is included in the tree)
/// 2. The DLEQ proof (that anchor and modified_commitment share the same secret)
/// 3. The Schnorr proof (that R_H is in the group generated by H)
/// 4. The leaf hash consistency
pub fn verify_anchored_proof(
    proof: &AnchoredProof,
    context: &VerificationContext,
) -> bool {
    // Step 1: Verify Merkle Proof
    // The proof's merkle_proof should verify that leaf_hash is in the tree
    let merkle_valid = proof.merkle_proof.verify(
        context.tree_root,
        &proof.merkle_proof.proof_hashes().iter().map(|_| 0).collect::<Vec<_>>(),
        &[proof.leaf_hash],
        1 << proof.merkle_proof.proof_hashes().len(), // Approximate leaves count
    );

    if !merkle_valid {
        return false;
    }

    // Step 2: Verify DLEQ Proof
    // Proves that log_B(anchor) = log_C(modified_commitment)
    let dleq_valid = verify_dleq_proof(
        &context.anchor,
        &proof.modified_commitment,
        &context.generator_b,
        &proof.commitment,
        &proof.dleq_proof.r_commitment_1,
        &proof.dleq_proof.r_commitment_2,
        &proof.dleq_proof.response,
    );

    if !dleq_valid {
        return false;
    }

    // Step 3: Verify Schnorr Proof
    // Reconstruct R_H = C' - P (where P is the point used in the leaf hash)
    let r_h = (proof.modified_commitment - proof.p_point).into_affine();

    let schnorr_valid = verify_schnorr_proof(
        &r_h,
        &context.generator_h,
        &proof.schnorr_proof.commitment,
        &proof.schnorr_proof.response,
    );

    if !schnorr_valid {
        return false;
    }

    // Step 4: All checks passed
    true
}

pub fn verify_anchored_proof_without_merkle(
    proof: &AnchoredProof,
    context: &VerificationContext,
) -> bool {
    // Verify DLEQ Proof
    let dleq_valid = verify_dleq_proof(
        &context.anchor,
        &proof.modified_commitment,
        &context.generator_b,
        &proof.commitment,
        &proof.dleq_proof.r_commitment_1,
        &proof.dleq_proof.r_commitment_2,
        &proof.dleq_proof.response,
    );

    if !dleq_valid {
        return false;
    }

    // Verify Schnorr Proof
    let r_h = (proof.modified_commitment - proof.p_point).into_affine();

    let schnorr_valid = verify_schnorr_proof(
        &r_h,
        &context.generator_h,
        &proof.schnorr_proof.commitment,
        &proof.schnorr_proof.response,
    );

    schnorr_valid
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{prove::generate_anchored_proof, setup::*, ProofInput};
    use ark_bn254::Fr;

    #[test]
    fn test_verify_proof() {
        // Setup
        let (g, h, b) = generator_setup();
        let secret = secret_setup();
        let blinding = secret_setup();
        let anchor = anchor_setup(&secret, &b);
        let range = 8;
        let tree = tree_setup(range, &anchor, &secret);

        // Select a witness
        let witness = Fr::from(1u64);

        // Generate proof
        let input = ProofInput {
            secret: &secret,
            witness: &witness,
            blinding: &blinding,
            generator_g: &g,
            generator_h: &h,
            generator_b: &b,
            anchor: &anchor,
            tree: &tree,
        };

        let proof = generate_anchored_proof(input);

        // Setup verification context
        let context = VerificationContext {
            generator_g: g,
            generator_h: h,
            generator_b: b,
            anchor,
            tree_root: tree.root().unwrap(),
        };

        // Verify the proof
        let valid = verify_anchored_proof_without_merkle(&proof, &context);
        assert!(valid, "Proof verification failed");
        println!("Proof verification passed!");
    }
}